//NguyenBS added
package net.fproject.tool.spring;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

public class Tables extends ArrayList<Table> {
	private static final long serialVersionUID = 1L;
	private Schema schema;

	public void setSchema(Schema schema) {
		this.schema = schema;
	}

	public Tables getMasterTables() {
		Tables tables = new Tables();
		for (Table tbl : this) {
			if (tbl.getParents() == null)
				tables.add(tbl);
		}
		return tables;
	}

	public Tables getNotBrowsedTables() {
		Tables tables = new Tables();
		for (Table tbl : this) {
			if (!tbl.isBrowsedTreeNode())
				tables.add(tbl);
		}
		return tables;
	}

	/**
	 * Sort order: the parent table is in first.
	 * */
	public void lazySort() {
		for (int i = 0; i < this.size(); i++)
			for (int j = i + 1; j < this.size(); j++) {
				Table tbli = this.get(i);
				Table tblj = this.get(j);
				if (tbli.isChildOf(tblj)) {
					this.remove(tbli);
					this.remove(tblj);
					this.add(i, tblj);
					this.add(j, tbli);
				}
			}
	}

	public void importTables() {
		try {
			ResultSet rs = schema
					.executeQuery("SELECT table_name,TABLE_COMMENT,ENGINE FROM information_schema.tables WHERE table_schema = '"
							+ schema.name + "'");

			while (rs.next()) {
				Table tbl = new Table(rs.getString(1), schema);
				tbl.comment = rs.getString(2);
				tbl.engine = rs.getString(3);
				this.add(tbl);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		for (Table tbl : this) {
			tbl.importColumns();
		}
		for (Table tbl : this) {
			for (Column col : tbl.columns) {
				if (col.referencedColumName != null
						&& col.referencedTableName != null) {
					Table parent = this.findByName(col.referencedTableName);
					tbl.addParent(parent);
					parent.addChild(tbl);
				}
			}
		}
	}

	public Table findByName(String tableName) {
		for (Table tbl : this) {
			if (tbl.name.equalsIgnoreCase(tableName)) {
				return tbl;
			}
		}
		return null;
	}

	public void generateMasterMessages(String tablePattern, String columnPattern) {
		if (tablePattern == null)
			tablePattern = "^mst.*";
		int cnt = 0;
		try {

			FileWriter msgFw = new FileWriter("mstmessage.properties");
			BufferedWriter msgBw = new BufferedWriter(msgFw);
			FileWriter javaFw = new FileWriter("MstCodeConstants.java");
			BufferedWriter javaBw = new BufferedWriter(javaFw);
			FileWriter asFw = new FileWriter("MstCodeConstants.as");
			BufferedWriter asBw = new BufferedWriter(asFw);

			javaBw.write("package com.fpt.fms.fi.common.utils;\r\n");
			javaBw
					.write("/*\r\n * This class is generated by FI2 Back-end Tool.\r\n");
			javaBw
					.write(" * The constant values are imported from Database \r\n * */\r\n");
			javaBw.write("public class MstCodeConstants {\r\n");

			asBw.write("package com.fpt.fms.fi.common.utils\r\n{\r\n");
			asBw
					.write("	/*\r\n	 * This class is generated by FI2 Back-end Tool.\r\n");
			asBw
					.write("	 * The constant values are imported from Database \r\n	 * */\r\n");
			asBw.write("	public class MstCodeConstants {\r\n");

			for (Table tbl : this) {
				if (tbl.name.matches(tablePattern)) {
					MasterTableMessage message = tbl
							.getMasterMessages(columnPattern);

					// Write mstmessage.properties
					if (!"".equals(message.message))
						msgBw.write(message.message);

					// Write MstCodeConstants.java
					if (!"".equals(message.javaSource))
						javaBw.write("	"
								+ message.javaSource
										.replaceAll("\r\n", "\r\n	").trim()
								+ "\r\n");

					// Write MstCodeConstants.as
					if (!"".equals(message.asSource))
						asBw.write("		"
								+ message.asSource.replaceAll("\r\n", "\r\n		")
										.trim() + "\r\n");
					cnt++;
				}
			}

			msgBw.close();
			msgFw.close();

			javaBw.write("}");

			javaBw.close();
			javaBw.close();

			asBw.write("	}\r\n}");

			asBw.close();
			asBw.close();

		} catch (Exception ex) {
			ex.printStackTrace();
		}

		System.out
				.println("Successfully generated master messages and source files for "
						+ cnt
						+ " entities from schema \""
						+ this.schema.name
						+ "\"");
	}

	public void generateRooScript() {
		try {
			FileWriter fw = new FileWriter(Helper.schema().name + ".roo");
			BufferedWriter bw = new BufferedWriter(fw);

			// Write down all master tables
			Tables tables = this.getMasterTables();
			for (Table tbl : tables) {
				bw.write(tbl.getRooScript(Helper.packageName));
			}

			// Browse tree top-down algorithm
			for (Table tbl : this) {
				bw.write(tbl.getRooScriptFromThisNode(Helper.packageName));
			}

			// Write down the rest
			tables = this.getNotBrowsedTables();
			tables.lazySort();
			for (Table tbl : tables) {
				bw.write(tbl.getRooScript(Helper.packageName));
			}

			bw.close();
			fw.close();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		System.out.println("Successfully generated " + Table.browsedTablesCount
				+ " entities from schema \"" + Helper.schema().name + "\"");
	}

	public void generateRooTestIntegrationScript() {
		try {
			FileWriter fw = new FileWriter(Helper.schema().name + "TestIntegration.roo");
			BufferedWriter bw = new BufferedWriter(fw);

			for (Table tbl : this) {
				bw.write(tbl.getRooTestIntegrationScript(Helper.packageName)+ "\r\n");
			}

			bw.close();
			fw.close();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		System.out
				.println("Successfully generated integration test script for "
						+ Table.browsedTablesCount + " entities from schema \""
						+ Helper.schema().name + "\"");
	}

	public void copyTableData() {
		Tables targetTables = new Tables();
		targetTables.setSchema(Helper.targetSchema());
		targetTables.importTables();

		try {
			// Copy all master tables
			Tables tables = targetTables.getMasterTables();

			for (Table tbl : tables) {
				tbl.copyTableData(targetTables.findByName(tbl.name));
			}

			// Copy tables by tree top-down algorithm
			for (Table tbl : this) {
				tbl.copyTablesFromThisNode(targetTables);
			}

			// Copy all the rest
			tables = this.getNotBrowsedTables();
			tables.lazySort();
			for (Table tbl : tables) {
				tbl.copyTableData(targetTables.findByName(tbl.name));
			}

			Helper.targetConnection.commit();
		} catch (SQLException e) {
			e.printStackTrace();
			return;
		}

		System.out.println("Successfully copied data from " + this.size()
				+ " tables in schema " + Helper.schema().name + " to schema "
				+ Helper.targetSchema().name);
	}

	public void updateColumnOrdinalPositions() {
		try {
			for (Table tbl : this) {
				System.out.println("\r\nUpdating table: " + tbl.name);
				tbl.updateTargetTable();
			}
			Helper.targetConnection.commit();
		} catch (SQLException e) {
			e.printStackTrace();
			return;
		}
		System.out.println("Successfully updated " + this.size()
				+ " tables in schema " + Helper.schema().name);
	}
}
